{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tcpb-client","text":"<p>Python client to communicate with TeraChem running in server mode.</p> <p>Client uses C-style sockets for communication and Protocol Buffers for data serialization.</p> <p>Structured input/output data from TeraChem running in server mode. Full access to all files written by TeraChem server if using TeraChem Frontend.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"unreleased","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Environment variable control for:</li> <li><code>TCPB_HOST</code></li> <li><code>TCPB_PORT</code></li> <li><code>TCPB_FRONTEND_HOST</code></li> <li><code>TCPB_FRONTEND_CLIENT</code></li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Collect <code>stdout</code> and files by default if using <code>TCPBFrontendClient</code></li> <li>Renamed <code>kwarg</code> to <code>compute</code> <code>raise_error</code> -&gt; <code>raise_exc</code> to match <code>qcop</code>.</li> <li>Default behavior for <code>TCPBFrontendClient</code> is now to collect stdout and files.</li> <li><code>program_output</code> appended to <code>exc.program_output</code>.</li> <li><code>TCPBFrontendClient</code> collects stdout and files even if a calculation fails.</li> </ul>"},{"location":"CHANGELOG/#0140-2024-09-10","title":"0.14.0 - 2024-09-10","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>GitHub workflows for basic code quality.</li> <li><code>release.py</code> script.</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Changed build system from <code>flit</code> to <code>poetry</code> to standardize with other <code>MtzGroup</code> lab projects.</li> <li>\ud83d\udea8 Updated minimum Python version from <code>3.7</code> -&gt; <code>3.9</code>.</li> <li>Updated package dependencies.</li> <li>Updated devops system. Removed <code>black</code>, <code>isort</code>, <code>flake8</code> in favor of latest version of <code>ruff</code>.</li> <li>Updated documentation dependencies.</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Checks for <code>bond_order</code> in the tests as this value is no longer returned by default by the TeraChem server.</li> <li><code>TCFEKeywords</code> checks. Just passing arguments to the <code>TCFEClient.compute()</code> function now.</li> </ul>"},{"location":"CHANGELOG/#0132","title":"0.13.2","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Bugfix by Christopher Myers to correct for loop handing CIS states.</li> </ul>"},{"location":"CHANGELOG/#0131","title":"0.13.1","text":""},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Pegged pydantic version &lt;2.0.</li> </ul>"},{"location":"CHANGELOG/#0130","title":"0.13.0","text":""},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Moved the <code>stdout</code> upon crashing of TeraChem server from <code>FailedOperation.extras</code> to <code>FailedOperation.error.extras</code>. This circumvents https://github.com/MolSSI/QCEngine/issues/397 and is probably a better place for the error data anyways.</li> </ul>"},{"location":"CHANGELOG/#0121","title":"0.12.1","text":""},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Hacked in a solution for the TeraChem server being off-by-one on the job directory so that we can collect stdout files when the server crashes. It's still impossible to collect stdout if its the first job (and a failed job) run by the server due to the server returning <code>-1</code> for the <code>job_dir</code> on the <code>status</code> message. Henry will look into fixing the server as per https://github.com/mtzgroup/terachem/issues/138.</li> </ul>"},{"location":"CHANGELOG/#0120","title":"0.12.0","text":""},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Bump support from python 3.6 -&gt; 3.7 (3.6 has end-of-life'd)</li> <li>Peg <code>protobuf</code> to <code>3.20.1</code> since newer versions do not support our outdated <code>_pb2.py</code> protobuf files.</li> </ul>"},{"location":"CHANGELOG/#0110","title":"0.11.0","text":""},{"location":"CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>Return <code>FailedOperation</code> instead of raising exceptions in <code>.compute()</code> methods.</li> <li>Use <code>TCFEKeywords</code> enums throughout code.</li> <li>Collect <code>tc.out</code>, if possible, when computation fails.</li> </ul>"},{"location":"CHANGELOG/#0101","title":"0.10.1","text":""},{"location":"CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>Moved <code>job_output_to_atomic_result</code> to be method on client objects so that <code>AtomicResult.provenance</code> can be dynamically set correctly depending on which client is used.</li> </ul>"},{"location":"CHANGELOG/#0100","title":"0.10.0","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Documentation and <code>mkdocs</code> website on GitHub pages. Docs available here</li> </ul>"},{"location":"CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>Renamed <code>AtomicInput.extras['tcfe:config']</code> -&gt; <code>AtomicInput.extras['tcfe:keywords']</code></li> </ul>"},{"location":"CHANGELOG/#090","title":"0.9.0","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li> <p>Configuration parameters for controlling <code>TCFrontEndClient</code> behavior:</p> </li> <li> <p><code>native_files</code>: list[str] - List of natives files to collect. If none passed, all files will be collected.</p> </li> <li> <p>Tests for <code>TCFrontEndClient</code> file put/get behaviors.</p> </li> </ul>"},{"location":"CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>Refactored <code>TCFrontEndClient</code></li> </ul>"},{"location":"CHANGELOG/#removed_1","title":"Removed","text":"<ul> <li>Construction of molden file from protocol buffer outputs. Molden files can now be requested directly from the Frontend client.</li> </ul>"},{"location":"CHANGELOG/#081","title":"0.8.1","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li> <p><code>TCFrontEndClient</code> to enable access to the files written by TeraChem and upload input files for TeraChem, in particular <code>c0</code> files as initial wavefunction guesses.</p> </li> <li> <p>Configuration parameters for controlling <code>TCFrontEndClient</code> behavior are     found in <code>AtomicInput.extras['tcfe:config']</code> and include:</p> <ol> <li><code>c0</code> | <code>ca0</code> and <code>cb0</code>: <code>bytes</code> - Binary files to use as an initial guess    wavefunction</li> <li><code>scratch_messy</code>: <code>bool</code> - If <code>True</code> client will not delete files on server    after a computation</li> <li><code>uploads_messy</code>: <code>bool</code> - If <code>True</code> client will not delete uploaded c0    file(s) after a computation</li> </ol> </li> <li>Client also supports AtomicResultProtocols <code>stdout</code> and <code>native_files</code>.</li> </ul>"},{"location":"CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li><code>qcelemental</code> required version bumped from <code>&gt;=0.17.0</code> to <code>&gt;=0.24.0</code> to support <code>native_files</code> field for returning files. See qcelemental note. Note I am breaking the convention and returning binary data as well since I have more control over file access via the <code>TCFrontEndClient</code> than anticipated in the <code>qcelemental</code>/<code>qcengine</code> specification. Additionally I need the binary <code>c0</code> file to use as initial guesses for TeraChem computations.</li> </ul>"},{"location":"CHANGELOG/#removed_2","title":"Removed","text":""},{"location":"CHANGELOG/#080-2021-05-26","title":"0.8.0 - 2021-05-26","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li>Many IMD values to the <code>result.extra['qcvars']</code> dict</li> <li><code>result.wavefunction</code> now contains <code>WavefunctionProperties</code></li> </ul>"},{"location":"CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li><code>result.extras['qcvars']['bond_order']</code> -&gt; <code>result.extras['qcvars']['meyer_bond_order']</code></li> <li>Many values in <code>result.extras['qcvars']</code> moved to <code>result.extras['job_extras']</code> if they didn't pertain to quantum chemistry values.</li> <li><code>result.extras['qcvars']['orb{a,b}_{energies,occupations}']</code> moved to <code>result.wavefunction</code>. Note these will only be returned if <code>AtomicInput.protocols.wavefunction = \"all\"</code>.</li> </ul>"},{"location":"CHANGELOG/#removed_3","title":"Removed","text":"<ul> <li>Removed unused documentation setup. Can add documentation with <code>mkdocs</code> later if needed.</li> </ul>"},{"location":"CHANGELOG/#072-2021-03-10","title":"0.7.2 - 2021-03-10","text":""},{"location":"CHANGELOG/#changed_12","title":"Changed","text":"<ul> <li>Learned that AtomicResult is supposed to be a full superset of AtomicInput used to generate the result. Changed <code>utils.job_output_to_atomic_result()</code> to reflect this reality.</li> </ul>"},{"location":"CHANGELOG/#071-2021-03-10","title":"0.7.1 - 2021-03-10","text":""},{"location":"CHANGELOG/#added_6","title":"Added","text":"<ul> <li><code>imd_orbital_type</code> specific keyword extraction to support creation of molden files.</li> </ul>"},{"location":"CHANGELOG/#070-2021-02-26","title":"0.7.0 - 2021-02-26","text":""},{"location":"CHANGELOG/#added_7","title":"Added","text":"<ul> <li><code>TCCloud.compute(atomic_input: AtomicInput) -&gt; AtomicResult</code> top level method to create MolSSI QCSchema compliant interface.</li> <li><code>pyproject.toml</code></li> <li>more examples in <code>/examples</code> that leverage the new QCSchema interface</li> <li><code>utils.py</code> that contains basic utilities for transforming inputs/outputs to <code>QCSchema</code> format.</li> </ul>"},{"location":"CHANGELOG/#changed_13","title":"Changed","text":"<ul> <li>Using <code>flit</code> instead of <code>setuptools</code> for packaging.</li> <li>Compatible with only python 3.6+ (adding type annotations)</li> </ul>"},{"location":"CHANGELOG/#removed_4","title":"Removed","text":"<ul> <li><code>setup.py</code></li> <li>Unused and broken test files including non functional mock server.</li> </ul>"},{"location":"CHANGELOG/#r060-2021-02-25","title":"r0.6.0 - 2021-02-25","text":""},{"location":"CHANGELOG/#changed_14","title":"Changed","text":"<ul> <li>Added Henry's molden file constructor function.</li> </ul>"},{"location":"CHANGELOG/#05x-long-long-ago","title":"0.5.x - Long long ago","text":""},{"location":"CHANGELOG/#added_8","title":"Added","text":"<ul> <li>All of Stefan's original code.</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#developing","title":"Developing","text":"<p>If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment.</p> <p>Note that lots of apparently unused code was removed from the repo to clean it up and make clear the actual code under development. To review all old code previously in the repo checkout the <code>r0.6.0</code> tag.</p>"},{"location":"CONTRIBUTING/#virtual-environment-with-venv","title":"Virtual environment with <code>venv</code>","text":"<p>You can create a virtual environment in a directory using Python's <code>venv</code> module:</p> <pre><code>$ python -m venv env\n</code></pre> <p>That will create a directory <code>./env/</code> with the Python binaries and then you will be able to install packages for that isolated environment.</p>"},{"location":"CONTRIBUTING/#activate-the-environment","title":"Activate the environment","text":"<p>Activate the new environment with:</p> <pre><code>$ source ./env/bin/activate\n</code></pre> <p>To check it worked, use:</p> <pre><code>$ which pip\nsome/directory/tcpb/env/bin/pip\n</code></pre> <p>If it shows the <code>pip</code> binary at <code>env/bin/pip</code> then it worked. \ud83c\udf89</p> <p>\u203c\ufe0f tip Every time you install a new package with <code>pip</code> under that environment, activate the environment again.</p> <p>This makes sure that if you use a terminal program installed by that package (like <code>flit</code>), you use the one from your local environment and not any other that could be installed globally.</p>"},{"location":"CONTRIBUTING/#flit","title":"Flit","text":"<p>tcpb uses Flit to build, package and publish the project.</p> <p>After activating the environment as described above, install <code>flit</code>:</p> <pre><code>$ pip install flit\n\n---&gt; 100%\n</code></pre> <p>Now re-activate the environment to make sure you are using the <code>flit</code> you just installed (and not a global one).</p> <p>And now use <code>flit</code> to install the development dependencies:</p> <pre><code>$ flit install --deps develop --symlink\n---&gt; 100%\n</code></pre> <p>It will install all the dependencies and your local tcpb in your local environment.</p>"},{"location":"CONTRIBUTING/#using-your-local-tcpb","title":"Using your local tcpb","text":"<p>If you create a Python file that imports and uses tcpb, and run it with the Python from your local environment, it will use your local tcpb source code.</p> <p>And if you update that local tcpb source code, as it is installed with <code>--symlink</code> (or <code>--pth-file</code> on Windows), when you run that Python file again, it will use the fresh version of tcpb you just edited.</p> <p>That way, you don't have to \"install\" your local version to be able to test every change.</p>"},{"location":"CONTRIBUTING/#tests","title":"Tests","text":"<p>Use <code>pytest</code> to test all the code.</p> <pre><code>pytest\n</code></pre> <p>This command requires a TeraChem server running on the host and server set in <code>tests/conftest.py</code>, <code>localhost</code> and port <code>11111</code> by default. Often running a TeraChem server on Fire and using port forwarding is the easiest way to accomplish this. Tests in the <code>tests/test_utils.py</code> file do not require a TeraChem server.</p>"},{"location":"clients/","title":"clients.py","text":""},{"location":"clients/#tcpb.clients.TCFrontEndClient","title":"tcpb.clients.TCFrontEndClient","text":"<pre><code>TCFrontEndClient(host: str = settings.tcpb_host, port: int = settings.tcpb_port, frontend_host: str = settings.tcpb_frontend_host, frontend_port: int = settings.tcpb_frontend_port, uploads_prefix: str = 'uploads', debug=False, trace=False)\n</code></pre> <p>Client for interacting with TeraChem FrontEnd.</p> <p>TeraChemFrontEndClient communicates with a TeraChem Protocol Buffer Server for QC compute jobs and with a file server to get/put files to the server. A file may be put to the server e.g., to use as an initial wave function guess, or any output file retrieved after a computation.</p> Source code in <code>tcpb/clients.py</code> <pre><code>def __init__(\n    self,\n    host: str = settings.tcpb_host,\n    port: int = settings.tcpb_port,\n    frontend_host: str = settings.tcpb_frontend_host,\n    frontend_port: int = settings.tcpb_frontend_port,\n    uploads_prefix: str = \"uploads\",\n    debug=False,\n    trace=False,\n):\n    self.frontend_host = frontend_host\n    self.frontend_port = frontend_port\n    self.uploads_prefix = uploads_prefix\n\n    super().__init__(host, port, debug, trace)\n</code></pre>"},{"location":"clients/#tcpb.clients.TCFrontEndClient.ls","title":"ls","text":"<pre><code>ls(path: str = '/') -&gt; List[Dict[str, str]]\n</code></pre> <p>List directories on TeraChem Server</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Optional filepath.</p> <code>'/'</code> Source code in <code>tcpb/clients.py</code> <pre><code>def ls(self, path: str = \"/\") -&gt; List[Dict[str, str]]:\n    \"\"\"List directories on TeraChem Server\n\n    Parameters:\n        path: Optional filepath.\n    \"\"\"\n    if not path.endswith(\"/\"):\n        path += \"/\"\n\n    req = self._request(\"GET\", path)\n    return req.json()\n</code></pre>"},{"location":"clients/#tcpb.clients.TCFrontEndClient.get","title":"get","text":"<pre><code>get(path: str) -&gt; bytes\n</code></pre> <p>Retrieve file from TeraChem Server</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Full filepath to the file to download. Does not begin with '/'.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes of the file. All files (text or binary) returned as bytes. So to</p> <code>bytes</code> <p>write to disk open file in binary mode. e.g.,: with open('my_output.txt', 'wb') as f:     f.write(client.get('path_to_file'))</p> Source code in <code>tcpb/clients.py</code> <pre><code>def get(self, path: str) -&gt; bytes:\n    \"\"\"Retrieve file from TeraChem Server\n\n    Parameters:\n        path: Full filepath to the file to download. Does not begin with '/'.\n\n    Returns:\n        Bytes of the file. All files (text or binary) returned as bytes. So to\n        write to disk open file in binary mode. e.g.,:\n            with open('my_output.txt', 'wb') as f:\n                f.write(client.get('path_to_file'))\n    \"\"\"\n    req = self._request(\"GET\", path)\n    return req.content\n</code></pre>"},{"location":"clients/#tcpb.clients.TCFrontEndClient.put","title":"put","text":"<pre><code>put(filename: str, content: bytes) -&gt; str\n</code></pre> <p>Upload a file to the TeraChem Server</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to the uploaded file.</p> <code>NOTE</code> <code>str</code> <p>Full path will vary from filename passed as server will place file into designated uploads directory with uuid in path.</p> Source code in <code>tcpb/clients.py</code> <pre><code>def put(self, filename: str, content: bytes) -&gt; str:\n    \"\"\"Upload a file to the TeraChem Server\n\n    Returns:\n        Path to the uploaded file.\n        NOTE: Full path will vary from filename passed as server will place file\n            into designated uploads directory with uuid in path.\n    \"\"\"\n    uuid = uuid4()\n    req = self._request(\n        \"PUT\", f\"{self.uploads_prefix}/{uuid}-{filename}\", content=content\n    )\n    return str(req.url.path)[1:]  # remove initial '/'\n</code></pre>"},{"location":"clients/#tcpb.clients.TCFrontEndClient.delete","title":"delete","text":"<pre><code>delete(path_or_filename: str) -&gt; None\n</code></pre> <p>Delete a directory or file from the TeraChem Server</p> Source code in <code>tcpb/clients.py</code> <pre><code>def delete(self, path_or_filename: str) -&gt; None:\n    \"\"\"Delete a directory or file from the TeraChem Server\"\"\"\n    with httpx.Client() as client:\n        req = client.delete(\n            f\"http://{self.host}:{self.frontend_port}/{path_or_filename}\"\n        )\n    req.raise_for_status()\n</code></pre>"},{"location":"clients/#tcpb.clients.TCFrontEndClient.compute","title":"compute","text":"<pre><code>compute(inp_data: ProgramInput, raise_exc: bool = True, collect_stdout: bool = True, collect_files: bool = True, rm_scratch_dir: bool = True, **kwargs) -&gt; ProgramOutput\n</code></pre> <p>Top level method for performing computations with qcio inputs/outputs</p> Configuration parameters for controlling TCFrontEndClient behavior are <p>found in ProgramInput.extras['tcfe:keywords'] and include:     1. 'c0' | 'ca0 and cb0': Binary files to use as an initial guess         wavefunction     2. 'scratch_messy': bool If True client will not delete files on server         after a computation     3. 'uploads_messy': bool If True client will not delete uploaded c0         file(s) after a computation     4. 'native_files': list[str] of filenames that will be downloaded after         a computation</p> <p>Parameters:</p> Name Type Description Default <code>prog_input</code> <p>ProgramInput object</p> required <code>collect_stdout</code> <code>bool</code> <p>bool, if True, will collect tc.out and place in ProgramOutput</p> <code>True</code> <code>collect_files</code> <code>bool</code> <p>bool, if True, will collect all files in the scratch directory.</p> <code>True</code> <code>rm_scratch_dir</code> <code>bool</code> <p>bool, if True, will remove the scratch directory after computation</p> <code>True</code> <code>raise_exc</code> <code>bool</code> <p>bool, if True, will raise an error if the computation fails</p> <code>True</code> Source code in <code>tcpb/clients.py</code> <pre><code>def compute(\n    self,\n    inp_data: ProgramInput,\n    raise_exc: bool = True,\n    collect_stdout: bool = True,\n    collect_files: bool = True,\n    rm_scratch_dir: bool = True,\n    **kwargs,\n) -&gt; ProgramOutput:\n    \"\"\"Top level method for performing computations with qcio inputs/outputs\n\n\n    NOTE: Configuration parameters for controlling TCFrontEndClient behavior are\n        found in ProgramInput.extras['tcfe:keywords'] and include:\n            1. 'c0' | 'ca0 and cb0': Binary files to use as an initial guess\n                wavefunction\n            2. 'scratch_messy': bool If True client will not delete files on server\n                after a computation\n            3. 'uploads_messy': bool If True client will not delete uploaded c0\n                file(s) after a computation\n            4. 'native_files': list[str] of filenames that will be downloaded after\n                a computation\n\n    Args:\n        prog_input: ProgramInput object\n        collect_stdout: bool, if True, will collect tc.out and place in ProgramOutput\n        collect_files: bool, if True, will collect all files in the scratch directory.\n        rm_scratch_dir: bool, if True, will remove the scratch directory after computation\n        raise_exc: bool, if True, will raise an error if the computation fails\n    \"\"\"\n\n    # Do pre-compute work\n    inp_data = self._pre_compute_tasks(inp_data)\n    # Send calculation to TC-PBS\n    try:\n        prog_output = super().compute(inp_data)\n    except ServerError as e:\n        exc = e\n        prog_output = e.program_output\n\n    # Do post-compute work\n    prog_output = self._post_compute_tasks(\n        prog_output,\n        collect_stdout=collect_stdout,\n        collect_files=collect_files,\n        rm_scratch_dir=rm_scratch_dir,\n    )\n    if raise_exc and prog_output.success is False:\n        # Append updated program_output with stdout/files to exception\n        exc.program_output = prog_output\n        raise exc\n\n    return prog_output\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient","title":"tcpb.clients.TCProtobufClient","text":"<pre><code>TCProtobufClient(host: str = settings.tcpb_host, port: int = settings.tcpb_port, debug=False, trace=False)\n</code></pre> <p>Connect and communicate with a TeraChem instance running in Protocol Buffer server mode (i.e. TeraChem was started with the -s|--server flag)</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname</p> <code>tcpb_host</code> <code>port</code> <code>int</code> <p>Port number (must be above 1023)</p> <code>tcpb_port</code> <code>debug</code> <p>If True, assumes connections work (used for testing with no server)</p> <code>False</code> <code>trace</code> <p>If True, packets are saved to .bin files (which can then be used for testing)</p> <code>False</code> Source code in <code>tcpb/clients.py</code> <pre><code>def __init__(\n    self,\n    host: str = settings.tcpb_host,\n    port: int = settings.tcpb_port,\n    debug=False,\n    trace=False,\n):\n    \"\"\"Initialize a TCProtobufClient object.\n\n    Parameters:\n        host: Hostname\n        port: Port number (must be above 1023)\n        debug: If True, assumes connections work (used for testing with no server)\n        trace: If True, packets are saved to .bin files (which can then be used for testing)\n    \"\"\"\n    if port &lt; 1023:\n        raise ValueError(\n            \"Port number is not allowed to below 1023 (system reserved ports)\"\n        )\n    self.host = host\n    self.port = port\n    self.debug = debug\n    self.trace = trace\n    if self.trace:\n        self.intracefile = open(\"client_recv.bin\", \"wb\")\n        self.outtracefile = open(\"client_sent.bin\", \"wb\")\n\n    self.tcsock = None\n    # Would like to not hard code this, but the truth is I am expecting exactly 8 bytes, not whatever Python thinks 2 ints is\n    self.header_size = 8\n\n    self.prev_results = None\n\n    self.curr_job_dir: Optional[str] = None\n    self.curr_job_scr_dir: Optional[str] = None\n    self.curr_job_id: Optional[int] = None\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.connect","title":"connect","text":"<pre><code>connect()\n</code></pre> <p>Connect to the TeraChem Protobuf server</p> Source code in <code>tcpb/clients.py</code> <pre><code>def connect(self):\n    \"\"\"Connect to the TeraChem Protobuf server\"\"\"\n    if self.debug:\n        logging.info(\"in debug mode - assume connection established\")\n        return\n\n    try:\n        self.tcsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.tcsock.settimeout(10.0)  # Timeout of 10 seconds\n        self.tcsock.connect((self.host, self.port))\n    except socket.error as msg:\n        raise ServerError(f\"Problem connecting to server: {msg}\", self)\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnect from the TeraChem Protobuf server</p> Source code in <code>tcpb/clients.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect from the TeraChem Protobuf server\"\"\"\n    if self.debug:\n        logging.info(\"in debug mode - assume disconnection worked\")\n        return\n\n    try:\n        self.tcsock.shutdown(2)  # Shutdown read and write\n        self.tcsock.close()\n        self.tcsock = None\n    except socket.error as msg:\n        logger.error(\n            f\"Problem communicating with server: {msg}. Disconnect assumed to have happened\"\n        )\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.is_available","title":"is_available","text":"<pre><code>is_available()\n</code></pre> <p>Asks the TeraChem Protobuf server whether it is available or busy through the Status protobuf message. Note that this does not reserve the server, and the status could change after this function is called.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the TeraChem PB server is currently available (no running job)</p> Source code in <code>tcpb/clients.py</code> <pre><code>def is_available(self):\n    \"\"\"Asks the TeraChem Protobuf server whether it is available or busy through the Status protobuf message.\n    Note that this does not reserve the server, and the status could change after this function is called.\n\n    Returns:\n        bool: True if the TeraChem PB server is currently available (no running job)\n    \"\"\"\n    if self.debug:\n        logging.info(\"in debug mode - assume terachem server is available\")\n        return True\n\n    # Send Status message\n    self._send_msg(pb.STATUS, None)\n\n    # Receive Status header\n    status = self._recv_msg(pb.STATUS)\n\n    return not status.busy\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.compute","title":"compute","text":"<pre><code>compute(inp_data: ProgramInput, raise_exc: bool = True, **kwargs) -&gt; ProgramOutput\n</code></pre> <p>Top level method for performing computations with QCSchema inputs/outputs</p> <p>Parameters:</p> Name Type Description Default <code>inp_data</code> <code>ProgramInput</code> <p>AtomicInput object</p> required <code>raise_exc</code> <code>bool</code> <p>If True, raise an error if the computation fails</p> <code>True</code> <p>Returns:</p> Type Description <code>ProgramOutput</code> <p>ProgramOutput object</p> Source code in <code>tcpb/clients.py</code> <pre><code>def compute(\n    self, inp_data: ProgramInput, raise_exc: bool = True, **kwargs\n) -&gt; ProgramOutput:\n    \"\"\"Top level method for performing computations with QCSchema inputs/outputs\n\n    Args:\n        inp_data: AtomicInput object\n        raise_exc: If True, raise an error if the computation fails\n\n    Returns:\n        ProgramOutput object\n    \"\"\"\n    # Create protobuf message\n    job_input_msg = prog_inp_to_job_inp(inp_data)\n    try:\n        # Send message to server; retry until accepted\n        accepted = False\n        retries = 0\n        while not accepted:\n            self._send_msg(pb.JOBINPUT, job_input_msg)\n            status = self._recv_msg(pb.STATUS)\n            self._set_status(status)\n            accepted = status.accepted\n            if not accepted:\n                retries += 1\n                if retries &gt; 10:\n                    raise ServerError(\"Server is busy and not accepting jobs\", self)\n                sleep(0.5)\n        while not self.check_job_complete():\n            sleep(0.25)\n        # Collect output from server\n        job_output = self._recv_msg(pb.JOBOUTPUT)\n    except ServerError as e:\n        # Server likely crashed due to calculation failing\n        prog_output = ProgramOutput(\n            input_data=inp_data,\n            success=False,\n            traceback=traceback.format_exc(),\n            results={},\n            provenance=Provenance(\n                program=self.program,\n                scratch_dir=self.curr_job_dir,\n            ),\n        )\n        e.program_output = prog_output\n        if raise_exc:\n            raise e\n        else:\n            return prog_output\n    else:\n        return self.job_output_to_atomic_result(\n            inp_data=inp_data, job_output=job_output\n        )\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.job_output_to_atomic_result","title":"job_output_to_atomic_result","text":"<pre><code>job_output_to_atomic_result(*, inp_data: ProgramInput, job_output: JobOutput) -&gt; ProgramOutput\n</code></pre> <p>Convert JobOutput to ProgramOutput</p> Source code in <code>tcpb/clients.py</code> <pre><code>def job_output_to_atomic_result(\n    self,\n    *,\n    inp_data: ProgramInput,\n    job_output: pb.JobOutput,\n) -&gt; ProgramOutput:\n    \"\"\"Convert JobOutput to ProgramOutput\"\"\"\n    # Convert job_output to python types\n    # NOTE: Required so that ProgramOutput is JSON serializable. Protobuf types are not.\n    jo_dict = MessageToDict(job_output, preserving_proto_field_name=True)\n\n    # Create ProgramOutput\n    prog_output: ProgramOutput = ProgramOutput(\n        input_data=inp_data,\n        success=True,\n        provenance=Provenance(\n            program=self.program, scratch_dir=jo_dict.get(\"job_dir\")\n        ),\n        results=to_single_point_results(job_output),\n    )\n    # And extend extras to include values additional to input extras\n    prog_output.results.extras.update(\n        {\n            \"charges\": jo_dict.get(\"charges\"),\n            \"spins\": jo_dict.get(\"spins\"),\n            \"meyer_bond_order\": jo_dict.get(\"bond_order\"),\n            \"orb_size\": jo_dict.get(\"orb_size\"),\n            \"excited_state_energies\": jo_dict.get(\"energy\"),\n            \"cis_transition_dipoles\": jo_dict.get(\"cis_transition_dipoles\"),\n            \"compressed_bond_order\": jo_dict.get(\"compressed_bond_order\"),\n            \"compressed_hessian\": jo_dict.get(\"compressed_hessian\"),\n            \"compressed_ao_data\": jo_dict.get(\"compressed_ao_data\"),\n            \"compressed_primitive_data\": jo_dict.get(\"compressed_primitive_data\"),\n            \"compressed_mo_vector\": jo_dict.get(\"compressed_mo_vector\"),\n            \"imd_mmatom_gradient\": jo_dict.get(\"imd_mmatom_gradient\"),\n            \"job_dir_scr\": jo_dict.get(\"job_scr_dir\"),\n            \"server_job_id\": jo_dict.get(\"server_job_id\"),\n            \"orb1afile\": jo_dict.get(\"orb1afile\"),\n            \"orb1bfile\": jo_dict.get(\"orb1bfile\"),\n        }\n    )\n\n    return prog_output\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.send_job_async","title":"send_job_async","text":"<pre><code>send_job_async(jobType='energy', geom=None, unitType='bohr', **kwargs)\n</code></pre> <p>Pack and send the current JobInput to the TeraChem Protobuf server asynchronously. This function expects a Status message back that either tells us whether the job was accepted.</p> <p>Parameters:</p> Name Type Description Default <code>jobType</code> <p>Job type key, as defined in the pb.JobInput.RunType enum (defaults to \"energy\")</p> <code>'energy'</code> <code>geom</code> <p>Cartesian geometry of the new point</p> <code>None</code> <code>unitType</code> <p>Unit type key, as defined in the pb.Mol.UnitType enum (defaults to \"bohr\")</p> <code>'bohr'</code> <code>**kwargs</code> <p>Additional TeraChem keywords, check _process_kwargs for behaviour</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True on job acceptance, False on server busy, and errors out if communication fails</p> Source code in <code>tcpb/clients.py</code> <pre><code>def send_job_async(self, jobType=\"energy\", geom=None, unitType=\"bohr\", **kwargs):\n    \"\"\"Pack and send the current JobInput to the TeraChem Protobuf server asynchronously.\n    This function expects a Status message back that either tells us whether the job was accepted.\n\n    Args:\n        jobType:    Job type key, as defined in the pb.JobInput.RunType enum (defaults to \"energy\")\n        geom:       Cartesian geometry of the new point\n        unitType:   Unit type key, as defined in the pb.Mol.UnitType enum (defaults to \"bohr\")\n        **kwargs:   Additional TeraChem keywords, check _process_kwargs for behaviour\n\n    Returns:\n        bool: True on job acceptance, False on server busy, and errors out if communication fails\n    \"\"\"\n    if jobType.upper() not in list(pb.JobInput.RunType.keys()):\n        raise ValueError(\n            \"Job type specified is not available in this version of the TCPB client\\n\"\n            \"Allowed run types: {}\".format(list(pb.JobInput.RunType.keys()))\n        )\n    if geom is None:\n        raise SyntaxError(\"Did not provide geometry to send_job_async()\")\n    if isinstance(geom, np.ndarray):\n        geom = geom.flatten()\n    if unitType.upper() not in list(pb.Mol.UnitType.keys()):\n        raise ValueError(\n            \"Unit type specified is not available in this version of the TCPB client\\n\"\n            \"Allowed unit types: {}\".format(list(pb.Mol.UnitType.keys()))\n        )\n\n    if self.debug:\n        logging.info(\"in debug mode - assume job completed\")\n        return True\n\n    # Job setup\n    job_input_msg = self._create_job_input_msg(jobType, geom, unitType, **kwargs)\n\n    self._send_msg(pb.JOBINPUT, job_input_msg)\n\n    status_msg = self._recv_msg(pb.STATUS)\n\n    if status_msg.WhichOneof(\"job_status\") == \"accepted\":\n        self._set_status(status_msg)\n\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.check_job_complete","title":"check_job_complete","text":"<pre><code>check_job_complete()\n</code></pre> <p>Pack and send a Status message to the TeraChem Protobuf server asynchronously. This function expects a Status message back with either working or completed set. Errors out if just busy message returned, implying the job we are checking was not submitted or had some other issue</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if job is completed, False otherwise</p> Source code in <code>tcpb/clients.py</code> <pre><code>def check_job_complete(self):\n    \"\"\"Pack and send a Status message to the TeraChem Protobuf server asynchronously.\n    This function expects a Status message back with either working or completed set.\n    Errors out if just busy message returned, implying the job we are checking was not submitted\n    or had some other issue\n\n    Returns:\n        bool: True if job is completed, False otherwise\n    \"\"\"\n    print(\"Checking jobs status...\")\n    if self.debug:\n        logging.info(\"in debug mode - assume check_job_complete is True\")\n        return True\n\n    # Send Status\n    self._send_msg(pb.STATUS, None)\n\n    # Receive Status\n    status = self._recv_msg(pb.STATUS)\n\n    if status.WhichOneof(\"job_status\") == \"completed\":\n        return True\n    elif status.WhichOneof(\"job_status\") == \"working\":\n        return False\n    else:\n        raise ServerError(\n            \"Invalid or no job status received, either no job submitted before check_job_complete() or major server issue\",\n            self,\n        )\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.recv_job_async","title":"recv_job_async","text":"<pre><code>recv_job_async()\n</code></pre> <p>Recv and unpack a JobOutput message from the TeraChem Protobuf server asynchronously. This function expects the job to be ready (i.e. check_job_complete() returned true), so will error out on timeout.</p> <p>Creates a results dictionary that mirrors the JobOutput message, using NumPy arrays when appropriate. Results are also saved in the prev_results class member. An inclusive list of the results members (with types):</p> <ul> <li>atoms:              Flat # of atoms NumPy array of 2-character strings</li> <li>geom:               # of atoms by 3 NumPy array of doubles</li> <li>energy:             Either empty, single energy, or flat # of cas_energy_labels of NumPy array of doubles</li> <li>charges:            Flat # of atoms NumPy array of doubles</li> <li>spins:              Flat # of atoms NumPy array of doubles</li> <li>dipole_moment:      Single element (units Debye)</li> <li>dipole_vector:      Flat 3-element NumPy array of doubles (units Debye)</li> <li>job_dir:            String</li> <li>job_scr_dir:        String</li> <li>server_job_id:      Int</li> <li>orbfile:            String (if restricted is True, otherwise not included)</li> <li>orbfile_a:          String (if restricted is False, otherwise not included)</li> <li>orbfile_b:          String (if restricted is False, otherwise not included)</li> <li>orb_energies:       Flat # of orbitals NumPy array of doubles (if restricted is True, otherwise not included)</li> <li>orb_occupations:    Flat # of orbitals NumPy array of doubles (if restricted is True, otherwise not included)</li> <li>orb_energies_a:     Flat # of orbitals NumPy array of doubles (if restricted is False, otherwise not included)</li> <li>orb_occupations_a:  Flat # of orbitals NumPy array of doubles (if restricted is False, otherwise not included)</li> <li>orb_energies_b:     Flat # of orbitals NumPy array of doubles (if restricted is False, otherwise not included)</li> <li>orb_occupations_b:  Flat # of orbitals NumPy array of doubles (if restricted is False, otherwise not included)</li> </ul> <p>Additional (optional) members of results:</p> <ul> <li>bond_order:         # of atoms by # of atoms NumPy array of doubles</li> </ul> <p>Available per job type:</p> <ul> <li>gradient:           # of atoms by 3 NumPy array of doubles (available for 'gradient' job)</li> <li>nacme:              # of atoms by 3 NumPy array of doubles (available for 'coupling' job)</li> <li>ci_overlap:         ci_overlap_size by ci_overlap_size NumPy array of doubles (available for 'ci_vec_overlap' job)</li> </ul> <p>Available for CAS jobs:</p> <ul> <li>cas_energy_labels:  List of tuples of (state, multiplicity) corresponding to the energy list</li> <li>cas_transition_dipole:  Flat 3-element NumPy array of doubles (available for 'coupling' job)</li> </ul> <p>Available for CIS jobs:</p> <ul> <li>cis_states:         Number of excited states for reported properties</li> <li>cis_unrelaxed_dipoles:    # of excited states list of flat 3-element NumPy arrays (default included with 'cis yes', or explicitly with 'cisunrelaxdipole yes', units a.u.)</li> <li>cis_relaxed_dipoles:      # of excited states list of flat 3-element NumPy arrays (included with 'cisrelaxdipole yes', units a.u.)</li> <li>cis_transition_dipoles:   # of excited state combinations (N(N-1)/2) list of flat 3-element NumPy arrays (default includeded with 'cis yes', or explicitly with 'cistransdipole yes', units a.u.)                             Order given lexically (e.g. 0-&gt;1, 0-&gt;2, 1-&gt;2 for 2 states)</li> </ul> <p>Returns:</p> Name Type Description <code>dict</code> <p>Results as described above</p> Source code in <code>tcpb/clients.py</code> <pre><code>def recv_job_async(self):\n    \"\"\"Recv and unpack a JobOutput message from the TeraChem Protobuf server asynchronously.\n    This function expects the job to be ready (i.e. check_job_complete() returned true),\n    so will error out on timeout.\n\n    Creates a results dictionary that mirrors the JobOutput message, using NumPy arrays when appropriate.\n    Results are also saved in the prev_results class member.\n    An inclusive list of the results members (with types):\n\n    * atoms:              Flat # of atoms NumPy array of 2-character strings\n    * geom:               # of atoms by 3 NumPy array of doubles\n    * energy:             Either empty, single energy, or flat # of cas_energy_labels of NumPy array of doubles\n    * charges:            Flat # of atoms NumPy array of doubles\n    * spins:              Flat # of atoms NumPy array of doubles\n    * dipole_moment:      Single element (units Debye)\n    * dipole_vector:      Flat 3-element NumPy array of doubles (units Debye)\n    * job_dir:            String\n    * job_scr_dir:        String\n    * server_job_id:      Int\n    * orbfile:            String (if restricted is True, otherwise not included)\n    * orbfile_a:          String (if restricted is False, otherwise not included)\n    * orbfile_b:          String (if restricted is False, otherwise not included)\n    * orb_energies:       Flat # of orbitals NumPy array of doubles (if restricted is True, otherwise not included)\n    * orb_occupations:    Flat # of orbitals NumPy array of doubles (if restricted is True, otherwise not included)\n    * orb_energies_a:     Flat # of orbitals NumPy array of doubles (if restricted is False, otherwise not included)\n    * orb_occupations_a:  Flat # of orbitals NumPy array of doubles (if restricted is False, otherwise not included)\n    * orb_energies_b:     Flat # of orbitals NumPy array of doubles (if restricted is False, otherwise not included)\n    * orb_occupations_b:  Flat # of orbitals NumPy array of doubles (if restricted is False, otherwise not included)\n\n    Additional (optional) members of results:\n\n    * bond_order:         # of atoms by # of atoms NumPy array of doubles\n\n    Available per job type:\n\n    * gradient:           # of atoms by 3 NumPy array of doubles (available for 'gradient' job)\n    * nacme:              # of atoms by 3 NumPy array of doubles (available for 'coupling' job)\n    * ci_overlap:         ci_overlap_size by ci_overlap_size NumPy array of doubles (available for 'ci_vec_overlap' job)\n\n    Available for CAS jobs:\n\n    * cas_energy_labels:  List of tuples of (state, multiplicity) corresponding to the energy list\n    * cas_transition_dipole:  Flat 3-element NumPy array of doubles (available for 'coupling' job)\n\n    Available for CIS jobs:\n\n    * cis_states:         Number of excited states for reported properties\n    * cis_unrelaxed_dipoles:    # of excited states list of flat 3-element NumPy arrays (default included with 'cis yes', or explicitly with 'cisunrelaxdipole yes', units a.u.)\n    * cis_relaxed_dipoles:      # of excited states list of flat 3-element NumPy arrays (included with 'cisrelaxdipole yes', units a.u.)\n    * cis_transition_dipoles:   # of excited state combinations (N(N-1)/2) list of flat 3-element NumPy arrays (default includeded with 'cis yes', or explicitly with 'cistransdipole yes', units a.u.)\n                                Order given lexically (e.g. 0-&gt;1, 0-&gt;2, 1-&gt;2 for 2 states)\n\n    Returns:\n        dict: Results as described above\n    \"\"\"\n    output = self._recv_msg(pb.JOBOUTPUT)\n\n    # Parse output into normal python dictionary\n    results = {\n        \"atoms\": np.array(output.mol.atoms, dtype=\"S2\"),\n        \"geom\": np.array(output.mol.xyz, dtype=np.float64).reshape(-1, 3),\n        \"charges\": np.array(output.charges, dtype=np.float64),\n        \"spins\": np.array(output.spins, dtype=np.float64),\n        \"dipole_moment\": output.dipoles[3],\n        \"dipole_vector\": np.array(output.dipoles[:3], dtype=np.float64),\n        \"job_dir\": output.job_dir,\n        \"job_scr_dir\": output.job_scr_dir,\n        \"server_job_id\": output.server_job_id,\n    }\n\n    if len(output.energy):\n        results[\"energy\"] = output.energy[0]\n\n    if output.mol.closed is True:\n        results[\"orbfile\"] = output.orb1afile\n\n        results[\"orb_energies\"] = np.array(output.orba_energies)\n        results[\"orb_occupations\"] = np.array(output.orba_occupations)\n    else:\n        results[\"orbfile_a\"] = output.orb1afile\n        results[\"orbfile_b\"] = output.orb1bfile\n\n        results[\"orb_energies_a\"] = np.array(output.orba_energies)\n        results[\"orb_occupations_a\"] = np.array(output.orba_occupations)\n        results[\"orb_energies_b\"] = np.array(output.orbb_energies)\n        results[\"orb_occupations_b\"] = np.array(output.orbb_occupations)\n\n    if len(output.gradient):\n        results[\"gradient\"] = np.array(output.gradient, dtype=np.float64).reshape(\n            -1, 3\n        )\n\n    if len(output.nacme):\n        results[\"nacme\"] = np.array(output.nacme, dtype=np.float64).reshape(-1, 3)\n\n    if len(output.cas_transition_dipole):\n        results[\"cas_transition_dipole\"] = np.array(\n            output.cas_transition_dipole, dtype=np.float64\n        )\n\n    if len(output.cas_energy_states):\n        results[\"energy\"] = np.array(\n            output.energy[: len(output.cas_energy_states)], dtype=np.float64\n        )\n        results[\"cas_energy_labels\"] = list(\n            zip(output.cas_energy_states, output.cas_energy_mults)\n        )\n\n    if len(output.bond_order):\n        nAtoms = len(output.mol.atoms)\n        results[\"bond_order\"] = np.array(\n            output.bond_order, dtype=np.float64\n        ).reshape(nAtoms, nAtoms)\n\n    if len(output.ci_overlaps):\n        results[\"ci_overlap\"] = np.array(\n            output.ci_overlaps, dtype=np.float64\n        ).reshape(output.ci_overlap_size, output.ci_overlap_size)\n\n    if output.cis_states &gt; 0:\n        results[\"energy\"] = np.array(\n            output.energy[: output.cis_states + 1], dtype=np.float64\n        )\n        results[\"cis_states\"] = output.cis_states\n\n        if len(output.cis_unrelaxed_dipoles):\n            uDips = []\n            for i in range(output.cis_states):\n                uDips.append(\n                    np.array(\n                        output.cis_unrelaxed_dipoles[4 * i : 4 * i + 3],\n                        dtype=np.float64,\n                    )\n                )\n            results[\"cis_unrelaxed_dipoles\"] = uDips\n\n        if len(output.cis_relaxed_dipoles):\n            rDips = []\n            for i in range(output.cis_states):\n                rDips.append(\n                    np.array(\n                        output.cis_relaxed_dipoles[4 * i : 4 * i + 3],\n                        dtype=np.float64,\n                    )\n                )\n            results[\"cis_relaxed_dipoles\"] = rDips\n\n        if len(output.cis_transition_dipoles):\n            tDips = []\n            for i in range(int((output.cis_states + 1) * output.cis_states / 2)):\n                tDips.append(\n                    np.array(\n                        output.cis_transition_dipoles[4 * i : 4 * i + 3],\n                        dtype=np.float64,\n                    )\n                )\n            results[\"cis_transition_dipoles\"] = tDips\n\n    # Save results for user access later\n    self.prev_results = results\n\n    # Wipe state\n    self.curr_job_dir = None\n    self.curr_job_scr_dir = None\n    self.curr_job_id = None\n\n    return results\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.compute_job_sync","title":"compute_job_sync","text":"<pre><code>compute_job_sync(jobType='energy', geom=None, unitType='bohr', **kwargs)\n</code></pre> <p>Wrapper for send_job_async() and recv_job_async(), using check_job_complete() to poll the server.</p> <p>Parameters:</p> Name Type Description Default <code>jobType</code> <p>Job type key, as defined in the pb.JobInput.RunType enum (defaults to 'energy')</p> <code>'energy'</code> <code>geom</code> <p>Cartesian geometry of the new point</p> <code>None</code> <code>unitType</code> <p>Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')</p> <code>'bohr'</code> <code>**kwargs</code> <p>Additional TeraChem keywords, check _process_kwargs for behaviour</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Results mirroring recv_job_async</p> Source code in <code>tcpb/clients.py</code> <pre><code>def compute_job_sync(self, jobType=\"energy\", geom=None, unitType=\"bohr\", **kwargs):\n    \"\"\"Wrapper for send_job_async() and recv_job_async(), using check_job_complete() to poll the server.\n\n    Args:\n        jobType:    Job type key, as defined in the pb.JobInput.RunType enum (defaults to 'energy')\n        geom:       Cartesian geometry of the new point\n        unitType:   Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')\n        **kwargs:   Additional TeraChem keywords, check _process_kwargs for behaviour\n\n    Returns:\n        dict: Results mirroring recv_job_async\n    \"\"\"\n    if self.debug:\n        logging.info(\n            \"in debug mode - assume compute_job_sync completed successfully\"\n        )\n        return True\n\n    accepted = self.send_job_async(jobType, geom, unitType, **kwargs)\n    while accepted is False:\n        sleep(0.5)\n        accepted = self.send_job_async(jobType, geom, unitType, **kwargs)\n\n    completed = self.check_job_complete()\n    while completed is False:\n        sleep(0.5)\n        completed = self.check_job_complete()\n\n    return self.recv_job_async()\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.compute_energy","title":"compute_energy","text":"<pre><code>compute_energy(geom=None, unitType='bohr', **kwargs)\n</code></pre> <p>Compute energy of a new geometry, but with the same atom labels/charge/spin multiplicity and wave function format as the previous calculation.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <p>Cartesian geometry of the new point</p> <code>None</code> <code>unitType</code> <p>Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')</p> <code>'bohr'</code> <code>**kwargs</code> <p>Additional TeraChem keywords, check _process_kwargs for behaviour</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Energy</p> Source code in <code>tcpb/clients.py</code> <pre><code>def compute_energy(self, geom=None, unitType=\"bohr\", **kwargs):\n    \"\"\"Compute energy of a new geometry, but with the same atom labels/charge/spin\n    multiplicity and wave function format as the previous calculation.\n\n    Args:\n        geom:       Cartesian geometry of the new point\n        unitType:   Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')\n        **kwargs:   Additional TeraChem keywords, check _process_kwargs for behaviour\n\n    Returns:\n        float: Energy\n    \"\"\"\n    results = self.compute_job_sync(\"energy\", geom, unitType, **kwargs)\n    return results[\"energy\"]\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.compute_gradient","title":"compute_gradient","text":"<pre><code>compute_gradient(geom=None, unitType='bohr', **kwargs)\n</code></pre> <p>Compute gradient of a new geometry, but with the same atom labels/charge/spin multiplicity and wave function format as the previous calculation.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <p>Cartesian geometry of the new point</p> <code>None</code> <code>unitType</code> <p>Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')</p> <code>'bohr'</code> <code>**kwargs</code> <p>Additional TeraChem keywords, check _process_kwargs for behaviour</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Tuple of (energy, gradient)</p> Source code in <code>tcpb/clients.py</code> <pre><code>def compute_gradient(self, geom=None, unitType=\"bohr\", **kwargs):\n    \"\"\"Compute gradient of a new geometry, but with the same atom labels/charge/spin\n    multiplicity and wave function format as the previous calculation.\n\n    Args:\n        geom:       Cartesian geometry of the new point\n        unitType:   Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')\n        **kwargs:   Additional TeraChem keywords, check _process_kwargs for behaviour\n\n    Returns:\n        tuple: Tuple of (energy, gradient)\n    \"\"\"\n    results = self.compute_job_sync(\"gradient\", geom, unitType, **kwargs)\n    return results[\"energy\"], results[\"gradient\"]\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.compute_forces","title":"compute_forces","text":"<pre><code>compute_forces(geom=None, unitType='bohr', **kwargs)\n</code></pre> <p>Compute forces of a new geometry, but with the same atoms labels/charge/spin multiplicity and wave function format as the previous calculation.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <p>Cartesian geometry of the new point</p> <code>None</code> <code>unitType</code> <p>Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')</p> <code>'bohr'</code> <code>**kwargs</code> <p>Additional TeraChem keywords, check _process_kwargs for behaviour</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Tuple of (energy, forces), which is really (energy, -gradient)</p> Source code in <code>tcpb/clients.py</code> <pre><code>def compute_forces(self, geom=None, unitType=\"bohr\", **kwargs):\n    \"\"\"Compute forces of a new geometry, but with the same atoms labels/charge/spin\n    multiplicity and wave function format as the previous calculation.\n\n    Args:\n        geom:       Cartesian geometry of the new point\n        unitType:   Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')\n        **kwargs:   Additional TeraChem keywords, check _process_kwargs for behaviour\n\n    Returns:\n        tuple: Tuple of (energy, forces), which is really (energy, -gradient)\n    \"\"\"\n    results = self.compute_job_sync(\"gradient\", geom, unitType, **kwargs)\n    return results[\"energy\"], -1.0 * results[\"gradient\"]\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.compute_coupling","title":"compute_coupling","text":"<pre><code>compute_coupling(geom=None, unitType='bohr', **kwargs)\n</code></pre> <p>Compute nonadiabatic coupling of a new geometry, but with the same atoms labels/charge/spin multiplicity and wave function format as the previous calculation.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <p>Cartesian geometry of the new point</p> <code>None</code> <code>unitType</code> <p>Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')</p> <code>'bohr'</code> <code>**kwargs</code> <p>Additional TeraChem keywords, check _process_kwargs for behaviour</p> <code>{}</code> <p>Returns:</p> Type Description <p>(num_atoms, 3) ndarray: Nonadiabatic coupling vector</p> Source code in <code>tcpb/clients.py</code> <pre><code>def compute_coupling(self, geom=None, unitType=\"bohr\", **kwargs):\n    \"\"\"Compute nonadiabatic coupling of a new geometry, but with the same atoms labels/charge/spin\n    multiplicity and wave function format as the previous calculation.\n\n    Args:\n        geom:       Cartesian geometry of the new point\n        unitType:   Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')\n        **kwargs:   Additional TeraChem keywords, check _process_kwargs for behaviour\n\n    Returns:\n        (num_atoms, 3) ndarray: Nonadiabatic coupling vector\n    \"\"\"\n    results = self.compute_job_sync(\"coupling\", geom, unitType, **kwargs)\n    return results[\"nacme\"]\n</code></pre>"},{"location":"clients/#tcpb.clients.TCProtobufClient.compute_ci_overlap","title":"compute_ci_overlap","text":"<pre><code>compute_ci_overlap(geom=None, geom2=None, cvec1file=None, cvec2file=None, orb1afile=None, orb1bfile=None, orb2afile=None, orb2bfile=None, unitType='bohr', **kwargs)\n</code></pre> <p>Compute wavefunction overlap given two different geometries, CI vectors, and orbitals, using the same atom labels/charge/spin multiplicity as the previous calculation.</p> <p>To run a closed shell calculation, only populate orb1afile/orb2afile, leaving orb1bfile/orb2bfile blank. Currently, open-shell overlap calculations are not supported by TeraChem.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <p>Cartesian geometry of the first point</p> <code>None</code> <code>geom2</code> <p>Cartesian geometry of the second point</p> <code>None</code> <code>cvec1file</code> <p>Binary file of CI vector for first geometry (row-major, double64)</p> <code>None</code> <code>cvec2file</code> <p>Binary file of CI vector for second geometry (row-major, double64)</p> <code>None</code> <code>orb1afile</code> <p>Binary file of alpha MO coefficients for first geometry (row-major, double64)</p> <code>None</code> <code>orb1bfile</code> <p>Binary file of beta MO coefficients for first geometry (row-major, double64)</p> <code>None</code> <code>orb2afile</code> <p>Binary file of alpha MO coefficients for second geometry (row-major, double64)</p> <code>None</code> <code>orb2bfile</code> <p>Binary file of beta MO coefficients for second geometry (row-major, double64)</p> <code>None</code> <code>unitType</code> <p>Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')</p> <code>'bohr'</code> <code>**kwargs</code> <p>Additional TeraChem keywords, check _process_kwargs for behaviour</p> <code>{}</code> <p>Returns:</p> Type Description <p>(num_states, num_states) ndarray: CI vector overlaps</p> Source code in <code>tcpb/clients.py</code> <pre><code>def compute_ci_overlap(\n    self,\n    geom=None,\n    geom2=None,\n    cvec1file=None,\n    cvec2file=None,\n    orb1afile=None,\n    orb1bfile=None,\n    orb2afile=None,\n    orb2bfile=None,\n    unitType=\"bohr\",\n    **kwargs,\n):\n    \"\"\"Compute wavefunction overlap given two different geometries, CI vectors, and orbitals,\n    using the same atom labels/charge/spin multiplicity as the previous calculation.\n\n    To run a closed shell calculation, only populate orb1afile/orb2afile, leaving orb1bfile/orb2bfile blank.\n    Currently, open-shell overlap calculations are not supported by TeraChem.\n\n    Args:\n        geom:       Cartesian geometry of the first point\n        geom2:      Cartesian geometry of the second point\n        cvec1file:  Binary file of CI vector for first geometry (row-major, double64)\n        cvec2file:  Binary file of CI vector for second geometry (row-major, double64)\n        orb1afile:  Binary file of alpha MO coefficients for first geometry (row-major, double64)\n        orb1bfile:  Binary file of beta MO coefficients for first geometry (row-major, double64)\n        orb2afile:  Binary file of alpha MO coefficients for second geometry (row-major, double64)\n        orb2bfile:  Binary file of beta MO coefficients for second geometry (row-major, double64)\n        unitType:   Unit type key, as defined in the pb.Mol.UnitType enum (defaults to 'bohr')\n        **kwargs:   Additional TeraChem keywords, check _process_kwargs for behaviour\n\n    Returns:\n        (num_states, num_states) ndarray: CI vector overlaps\n    \"\"\"\n    if geom is None or geom2 is None:\n        raise SyntaxError(\"Did not provide two geometries to compute_ci_overlap()\")\n    if cvec1file is None or cvec2file is None:\n        raise SyntaxError(\"Did not provide two CI vectors to compute_ci_overlap()\")\n    if orb1afile is None or orb1bfile is None:\n        raise SyntaxError(\n            \"Did not provide two sets of orbitals to compute_ci_overlap()\"\n        )\n    if (\n        (orb1bfile is not None and orb2bfile is None)\n        or (orb1bfile is None and orb2bfile is not None)\n        and kwargs[\"closed_shell\"] is False\n    ):\n        raise SyntaxError(\n            \"Did not provide two sets of open-shell orbitals to compute_ci_overlap()\"\n        )\n    elif (\n        orb1bfile is not None\n        and orb2bfile is not None\n        and kwargs[\"closed_shell\"] is True\n    ):\n        print(\n            \"WARNING: System specified as closed, but open-shell orbitals were passed to compute_ci_overlap(). Ignoring beta orbitals.\"\n        )\n\n    if kwargs[\"closed_shell\"]:\n        results = self.compute_job_sync(\n            \"ci_vec_overlap\",\n            geom,\n            unitType,\n            geom2=geom2,\n            cvec1file=cvec1file,\n            cvec2file=cvec2file,\n            orb1afile=orb1afile,\n            orb2afile=orb2afile,\n            **kwargs,\n        )\n    else:\n        raise RuntimeError(\n            \"WARNING: Open-shell systems are currently not supported for overlaps\"\n        )\n        # results = self.compute_job_sync(\"ci_vec_overlap\", geom, unitType, geom2=geom2,\n        #    cvec1file=cvec1file, cvec2file=cvec2file,\n        #    orb1afile=orb1afile, orb1bfile=orb1bfile,\n        #    orb2afile=orb1bfile, orb2bfile=orb2bfile, **kwargs)\n\n    return results[\"ci_overlap\"]\n</code></pre>"},{"location":"random_observations/","title":"Random Observations","text":"<p>This document provides some rough usage documentation notes.</p>"},{"location":"random_observations/#guess-vs-orb1afileorb1bfile","title":"guess vs orb1afile/orb1bfile","text":"<p>If you want to use a guess wavefunction for a subsequent calculation (i.e., pass the <code>c0</code> file from TeraChem to a new calculation):</p> <ul> <li> <p>For an energy/gradient calculation you pass the <code>path/to/c0</code> using the keyword <code>guess</code> in the <code>user_options</code> field. See <code>examples/guess_reuse_example.py</code> and note the passing of a string that indicates the filepath on the server than TeraChem should use:</p> </li> <li> <p>Closed shell <code>guess=path/to/c0</code></p> </li> <li> <p>Open shell <code>guess=path/to/ca0 path/to/cb0</code></p> <ul> <li>Note with open shell the filenames change from <code>c0</code> -&gt; <code>ca0</code> and <code>cb0</code></li> </ul> </li> <li> <p>For ci_overlap computations you pass the <code>c0</code> file in the <code>orb1afile</code> and <code>orb1bfile</code> fields. See <code>examples/ci_overlap_example.py</code></p> </li> </ul> <p>I (Colton) do not understand why this difference exists. It seems to be an artifact of not noticing there are multiple ways to pass the same file and perhaps should be remedied in a future release of the TeraChem PB server.</p>"},{"location":"Examples/basic_energy/","title":"Basic Energy","text":"<pre><code>#!/usr/bin/env python\n# Basic energy calculation\nimport sys\n\nfrom qcio import ProgramInput, Structure\n\nfrom tcpb import TCProtobufClient as TCPBClient\n\nif len(sys.argv) != 3:\n    print(\"Usage: {} host port\\n\".format(sys.argv[0]))\n    exit(1)\n\n\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[[0.0, 0.0, 0.0], [0.0, 1.5, 0.0], [0.0, 0.0, 1.5]],\n)\nprog_inp = ProgramInput(\n    calctype=\"energy\",  # type: ignore\n    structure=structure,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},  # type: ignore\n)\n\nwith TCPBClient(host=sys.argv[1], port=int(sys.argv[2])) as client:\n    prog_output = client.compute(prog_inp)\n\nprint(prog_output)\nprint(prog_output.results.energy)\n</code></pre>"},{"location":"Examples/ci_overlap/","title":"CI Overlap","text":"<pre><code>#! /usr/bin/env python\n# Test of ci_vec_overlap job through TCPB\n\nimport os\nimport sys\n\nfrom tcpb import TCProtobufClient as TCPBClient\n\n# Ethylene system\natoms = [\"C\", \"C\", \"H\", \"H\", \"H\", \"H\"]\ngeom = [\n    0.35673483,\n    -0.05087227,\n    -0.47786734,\n    1.61445821,\n    -0.06684947,\n    -0.02916681,\n    -0.14997206,\n    0.87780529,\n    -0.62680155,\n    -0.16786485,\n    -0.95561368,\n    -0.69426370,\n    2.15270896,\n    0.84221076,\n    0.19314809,\n    2.16553127,\n    -0.97886933,\n    0.15232587,\n]\ngeom2 = [\n    0.35673483,\n    -0.05087227,\n    -0.47786734,\n    1.61445821,\n    -0.06684947,\n    -0.02916681,\n    -0.14997206,\n    0.87780529,\n    -0.62680155,\n    -0.16786485,\n    -0.95561368,\n    -0.69426370,\n    2.15270896,\n    0.84221076,\n    0.19314809,\n    2.16553127,\n    -0.97886933,\n    0.15232587,\n]\n\nif len(sys.argv) != 3:\n    print(\"Usage: {} host port\".format(sys.argv[0]))\n    exit(1)\n\nwith TCPBClient(host=sys.argv[1], port=int(sys.argv[2])) as TC:\n    base_options = {\n        \"atoms\": atoms,\n        \"charge\": 0,\n        \"spinmult\": 1,\n        \"closed_shell\": True,\n        \"restricted\": True,\n        \"method\": \"hf\",\n        \"basis\": \"6-31g**\",\n        \"precision\": \"double\",\n        \"threall\": 1.0e-20,\n        \"casci\": \"yes\",\n        \"closed\": 5,\n        \"active\": 6,\n        \"cassinglets\": 10,\n    }\n\n    # First run CASCI to get some test CI vectors\n    casci_options = {\"directci\": \"yes\", \"caswritevecs\": \"yes\"}\n    options = dict(base_options, **casci_options)\n    results = TC.compute_job_sync(\"energy\", geom, \"angstrom\", **options)\n\n    # Run ci_vec_overlap job based on last job\n    overlap_options = {\n        \"geom2\": geom2,\n        \"cvec1file\": os.path.join(results[\"job_scr_dir\"], \"CIvecs.Singlet.dat\"),\n        \"cvec2file\": os.path.join(results[\"job_scr_dir\"], \"CIvecs.Singlet.dat\"),\n        \"orb1afile\": os.path.join(results[\"job_scr_dir\"], \"c0\"),\n        \"orb2afile\": os.path.join(results[\"job_scr_dir\"], \"c0\"),\n    }\n    options = dict(base_options, **overlap_options)\n    results = TC.compute_job_sync(\"ci_vec_overlap\", geom, \"angstrom\", **options)\n\n    print(\"Overlap:\\n{}\".format(results[\"ci_overlap\"]))\n</code></pre>"},{"location":"Examples/cisno_casci%20copy/","title":"FOMO CASCI","text":"<p>Note this method is currently returning results that are different from previous for unknown reasons.</p> <pre><code>#!/usr/bin/env python\n# Simple example showing a FOMO-CASCI calculation\n\nimport sys\n\nfrom tcpb import TCProtobufClient as TCPBClient\n\n# Ethene system\natoms = [\"C\", \"C\", \"H\", \"H\", \"H\", \"H\"]\ngeom = [\n    0.35673483,\n    -0.05087227,\n    -0.47786734,\n    1.61445821,\n    -0.06684947,\n    -0.02916681,\n    -0.14997206,\n    0.87780529,\n    -0.62680155,\n    -0.16786485,\n    -0.95561368,\n    -0.69426370,\n    2.15270896,\n    0.84221076,\n    0.19314809,\n    2.16553127,\n    -0.97886933,\n    0.15232587,\n]\n\nif len(sys.argv) != 3:\n    print(\"Usage: {} host port\".format(sys.argv[0]))\n    exit(1)\n\nwith TCPBClient(host=sys.argv[1], port=int(sys.argv[2])) as TC:\n    options = {\n        \"method\": \"hf\",\n        \"basis\": \"6-31g**\",\n        \"atoms\": atoms,\n        \"charge\": 0,\n        \"spinmult\": 1,\n        \"closed_shell\": True,\n        \"restricted\": True,\n        \"precision\": \"double\",\n        \"threall\": 1e-20,\n        \"casci\": \"yes\",\n        \"fon\": \"yes\",\n        \"closed\": 7,\n        \"active\": 2,\n        \"cassinglets\": 2,\n        \"nacstate1\": 0,\n        \"nacstate2\": 1,\n    }\n\n    # NACME calculation\n    results = TC.compute_job_sync(\"coupling\", geom, \"angstrom\", **options)\n    print(results)\n</code></pre>"},{"location":"Examples/cisno_casci/","title":"CISNO CASCI","text":"<pre><code>#!/usr/bin/env python\n# Simple example showing a CISNO-CASCI calculation\n\nimport sys\n\nfrom tcpb import TCProtobufClient as TCPBClient\n\n# Ethene system\natoms = [\"C\", \"C\", \"H\", \"H\", \"H\", \"H\"]\ngeom = [\n    0.35673483,\n    -0.05087227,\n    -0.47786734,\n    1.61445821,\n    -0.06684947,\n    -0.02916681,\n    -0.14997206,\n    0.87780529,\n    -0.62680155,\n    -0.16786485,\n    -0.95561368,\n    -0.69426370,\n    2.15270896,\n    0.84221076,\n    0.19314809,\n    2.16553127,\n    -0.97886933,\n    0.15232587,\n]\n\nif len(sys.argv) != 3:\n    print(\"Usage: {} host port\".format(sys.argv[0]))\n    exit(1)\n\nwith TCPBClient(host=sys.argv[1], port=int(sys.argv[2])) as TC:\n    base_options = {\n        \"method\": \"hf\",\n        \"basis\": \"6-31g**\",\n        \"atoms\": atoms,\n        \"charge\": 0,\n        \"spinmult\": 1,\n        \"closed_shell\": True,\n        \"restricted\": True,\n        \"precision\": \"double\",\n        \"convthre\": 1e-8,\n        \"threall\": 1e-20,\n    }\n\n    cisno_options = {\n        \"cisno\": \"yes\",\n        \"cisnostates\": 2,\n        \"cisnumstates\": 2,\n        \"closed\": 7,\n        \"active\": 2,\n        \"cassinglets\": 2,\n        \"dcimaxiter\": 100,\n    }\n    options = dict(base_options, **cisno_options)\n    results = TC.compute_job_sync(\"energy\", geom, \"angstrom\", **options)\n    print(results)\n</code></pre>"},{"location":"Examples/frontend/","title":"TCFrontEndClient","text":"<pre><code>#!/usr/bin/env python\n# Basic energy calculation\nimport sys\n\nfrom qcio import ProgramInput, Structure\n\nfrom tcpb import TCFrontEndClient\n\nif len(sys.argv) != 3:\n    print(f\"Usage: {sys.argv[0]} host port\")\n    exit(1)\n\n\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"], geometry=[0.0, 0.0, 0.0, 0.0, 1.5, 0.0, 0.0, 0.0, 1.5]\n)\natomic_input = ProgramInput(\n    structure=structure,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},  # type: ignore\n    calctype=\"energy\",  # type: ignore\n    keywords={\"restricted\": False},\n)\n\nwith TCFrontEndClient(host=sys.argv[1], port=int(sys.argv[2])) as client:\n    # Collect stdout and native files\n    prog_output = client.compute(atomic_input, collect_stdout=True, collect_files=True)\n\n# NOTE: Addition of stdout field possible with TCFrontendClient\nprint(prog_output.stdout)\nprint(prog_output)\nprint(prog_output.return_result)\n# native_files will contain orb1a/b files in binary form\nprint(prog_output.files.keys())\n</code></pre>"},{"location":"Examples/frontend_guess_reuse/","title":"Frontend Guess Reuse","text":"<pre><code>#!/usr/bin/env python\n# Basic energy calculation\nimport sys\n\nfrom qcio import CalcType, ProgramInput, Structure\n\nfrom tcpb import TCFrontEndClient\n\nif len(sys.argv) != 3:\n    print(f\"Usage: {sys.argv[0]} host port\")\n    exit(1)\n\n\nstruct = Structure(\n    symbols=[\"O\", \"H\", \"H\"], geometry=[0.0, 0.0, 0.0, 0.0, 1.5, 0.0, 0.0, 0.0, 1.5]\n)\nprog_inp = ProgramInput(\n    calctype=CalcType.energy,\n    structure=struct,\n    model={\"method\": \"b3lyp\", \"basis\": \"6-31g\"},  # type: ignore\n    # Density matrix purification appears buggy and messes with initial guess\n    keywords={\"purify\": \"no\"},\n)\n\nwith TCFrontEndClient(host=sys.argv[1], port=int(sys.argv[2])) as client:\n    prog_output = client.compute(prog_inp, collect_files=True)\n\nprog_inp_2 = prog_inp.model_dump()\nprog_inp_2[\"files\"][\"c0\"] = prog_output.results.files[\"scr/c0\"]\n\nwith TCFrontEndClient(host=sys.argv[1], port=int(sys.argv[2])) as client:\n    prog_output_2 = client.compute(ProgramInput(**prog_inp_2))\n\nprint(prog_output.stdout)\nprint(prog_output_2.stdout)\n</code></pre>"},{"location":"Examples/guess_reuse/","title":"Guess Reuse","text":"<pre><code>#!/usr/bin/env python\n# Guess reuse example\n\nimport os\nimport sys\n\nfrom tcpb import TCProtobufClient\n\n# Water system\natoms = [\"O\", \"H\", \"H\"]\ngeom = [\n    0.00000,\n    0.00000,\n    -0.06852,\n    0.00000,\n    -0.79069,\n    0.54370,\n    0.00000,\n    0.79069,\n    0.54370,\n]\n# Default geom is bohr, but this in angstrom\n\nif len(sys.argv) != 3:\n    print(\"Usage: {} host port\".format(sys.argv[0]))\n    exit(1)\n\nwith TCProtobufClient(host=sys.argv[1], port=int(sys.argv[2])) as TC:\n    tc_opts = {\n        \"atoms\": atoms,\n        \"charge\": 0,\n        \"spinmult\": 1,\n        \"closed_shell\": True,\n        \"restricted\": True,\n        \"method\": \"pbe0\",\n        \"basis\": \"6-31g\",\n        # necessary to avoid density matrix purification on second calc which will\n        # cause second calc to begin at different starting point than where first cals\n        # ended\n        \"purify\": \"no\",\n    }\n\n    results = TC.compute_job_sync(\"gradient\", geom, \"bohr\", **tc_opts)\n\n    # We can pull the orbital path from the previous job to feed in as a guess\n    orb_path = os.path.join(results[\"job_scr_dir\"], \"c0\")\n    results = TC.compute_job_sync(\"gradient\", geom, \"bohr\", guess=orb_path, **tc_opts)\n\n    # Things look slightly different for unrestricted guesses\n    tc_opts[\"closed_shell\"] = False\n    tc_opts[\"restricted\"] = False\n    results = TC.compute_job_sync(\"gradient\", geom, \"angstrom\", **tc_opts)\n\n    # TeraChem expects \"guess &lt;ca0 file&gt; &lt;cb0 file&gt;\"\n    orb_paths = \"{0}/ca0 {0}/cb0\".format(results[\"job_scr_dir\"])\n    print(orb_paths)\n    results = TC.compute_job_sync(\n        \"gradient\", geom, \"angstrom\", guess=orb_paths, **tc_opts\n    )\n</code></pre>"},{"location":"Examples/sa_casscf/","title":"SA CASSCF","text":"<pre><code>#!/usr/bin/env python\n# Simple example showing an alpha-SA-CASSCF calculation\n\nimport sys\n\nfrom tcpb import TCProtobufClient as TCPBClient\n\n# Ethene system\natoms = [\"C\", \"C\", \"H\", \"H\", \"H\", \"H\"]\ngeom = [\n    0.35673483,\n    -0.05087227,\n    -0.47786734,\n    1.61445821,\n    -0.06684947,\n    -0.02916681,\n    -0.14997206,\n    0.87780529,\n    -0.62680155,\n    -0.16786485,\n    -0.95561368,\n    -0.69426370,\n    2.15270896,\n    0.84221076,\n    0.19314809,\n    2.16553127,\n    -0.97886933,\n    0.15232587,\n]\n\nif len(sys.argv) != 3:\n    print(\"Usage: {} host port\".format(sys.argv[0]))\n    exit(1)\n\nwith TCPBClient(host=sys.argv[1], port=int(sys.argv[2])) as TC:\n    base_options = {\n        \"method\": \"hf\",\n        \"basis\": \"6-31g**\",\n        \"atoms\": atoms,\n        \"charge\": 0,\n        \"spinmult\": 1,\n        \"closed_shell\": True,\n        \"restricted\": True,\n        \"precision\": \"double\",\n        \"threall\": 1e-20,\n    }\n\n    casscf_options = {\n        \"casscf\": \"yes\",\n        \"closed\": 7,\n        \"active\": 2,\n        \"cassinglets\": 2,\n        \"castarget\": 1,\n        \"alphacas\": \"yes\",\n        \"alpha\": 0.73,\n    }\n\n    # Excited state gradient\n    options = dict(base_options, **casscf_options)\n    results = TC.compute_job_sync(\"gradient\", geom, \"angstrom\", **options)\n    print(results)\n\n    # S0/S1 Coupling\n    options[\"nacstate1\"] = 0\n    options[\"nacstate2\"] = 1\n    results = TC.compute_job_sync(\"coupling\", geom, \"angstrom\", **options)\n    print(results)\n</code></pre>"},{"location":"Examples/tddft/","title":"TDDFT","text":""},{"location":"Examples/tddft/#frontend-guess-reuse","title":"Frontend Guess Reuse","text":"<pre><code>#!/usr/bin/env python\n# Simple example showing a TDDFT calculation\n\nimport sys\n\nfrom tcpb import TCProtobufClient as TCPBClient\n\n# Ethene system\natoms = [\"C\", \"C\", \"H\", \"H\", \"H\", \"H\"]\ngeom = [\n    0.35673483,\n    -0.05087227,\n    -0.47786734,\n    1.61445821,\n    -0.06684947,\n    -0.02916681,\n    -0.14997206,\n    0.87780529,\n    -0.62680155,\n    -0.16786485,\n    -0.95561368,\n    -0.69426370,\n    2.15270896,\n    0.84221076,\n    0.19314809,\n    2.16553127,\n    -0.97886933,\n    0.15232587,\n]\n\nif len(sys.argv) != 3:\n    print(\"Usage: {} host port\".format(sys.argv[0]))\n    exit(1)\n\nwith TCPBClient(host=sys.argv[1], port=int(sys.argv[2])) as TC:\n    tddft_options = {\n        \"atoms\": atoms,\n        \"charge\": 0,\n        \"spinmult\": 1,\n        \"closed_shell\": True,\n        \"restricted\": True,\n        \"method\": \"wpbeh\",\n        \"rc_w\": 0.2,\n        \"basis\": \"6-31g\",\n        \"cis\": \"yes\",\n        \"cistarget\": 1,\n        \"cisnumstates\": 3,\n        \"cisrelaxdipole\": \"yes\",\n    }\n\n    # Gradient calculation\n    grad_results = TC.compute_job_sync(\"gradient\", geom, \"angstrom\", **tddft_options)\n    print(\"Grad Results:\\n{}\".format(grad_results))\n\n    # Coupling calculation\n    nac_options = tddft_options.copy()\n    nac_options[\"nacstate1\"] = 0\n    nac_options[\"nacstate2\"] = 1\n    # Try to seed as much guess as possible\n    # TODO: Update this one CI and Z vectors are passed through properly\n    nac_options[\"guess\"] = \"{}/{}\".format(grad_results[\"job_scr_dir\"], \"c0\")\n\n    nac_results = TC.compute_job_sync(\"coupling\", geom, \"angstrom\", **nac_options)\n    print(\"\\nNAC Results:\\n{}\".format(nac_results))\n</code></pre>"}]}